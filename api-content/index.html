{"posts":[{"title":"java面试题之HashMap常见面试题总结","content":"“你用过HashMap吗？” “什么是HashMap？你为什么用到它？” 几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。 “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。 “如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？” 除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。如果你能够回答这道问题，下面的问题来了： “你了解重新调整HashMap大小存在什么问题吗？” 你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：） “为什么String, Interger这样的wrapper类适合作为键？” String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 “我们可以使用自定义的对象作为键吗？ ”这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 “我们可以使用CocurrentHashMap来代替Hashtable吗？” 这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。 这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结 HashMap的工作原理HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。因为HashMap的好处非常多，在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章: ","link":"https://blog.elex.vip/post/java-mian-shi-ti-zhi-hashmap-chang-jian-mian-shi-ti-zong-jie/"},{"title":"BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）","content":" 前后端交互BigDecimal类型字段丢失精度 例如 解决方案 注解解释 (BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）) 前后端交互BigDecimal类型字段丢失精度 例如 postman 的返回： 例如 前端接收 的返回： 实体类里的字段类型： 例如 该字段的值为 “ 12345671234567.12345”，到前端就变成了 “12345671234567.123”，前端要求保留所有小数。 解决方案 在需要转化的字段上添加 @JsonFormat(shape = JsonFormat.Shape.STRING) 注解 注解解释 @JsonFormat 用来表示json序列化的一种格式或者类型，shap表示序列化后的一种类型 ","link":"https://blog.elex.vip/post/bigdecimal-postman-fan-hui-zheng-chang-jing-du-qian-duan-jie-shou-bu-zheng-chang-qian-hou-duan-jiao-hu-diu-shi-jing-du/"},{"title":"Java-Poi 指定列单元格式","content":" POI导出设置某列值为文本格式 HSSFWorkbook方式 XSSFWorkbook方式 ( Java-Poi 指定列单元格式) POI导出设置某列值为文本格式 HSSFWorkbook方式 XSSFWorkbook方式 poi的jar包版本：3.10 ","link":"https://blog.elex.vip/post/java-poi-zhi-ding-lie-dan-yuan-ge-shi/"},{"title":"Sql Server + Mybatis-plus使用Page时报错","content":" “OFFSET”附近有语法错误 代码实现 错误信息 解决过程 定位问题 解决方案 (Sql Server + Mybatis-plus使用Page时报错：) “OFFSET”附近有语法错误 最近开发遇到的问题，SqlServer+Mybatis-Plus Page插件进行分页时的报错 代码实现 Maven依赖 Mapper.xml 错误信息 解决过程 定位问题 找到报错的sql 控制显示的一句异常信息 进入com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor.java,在concatOrderBy打上断点 在执行该句代码时异常： 在控制台debug监视CCJSqlParserUtil.parse(originalSql)，直接抛出异常，是sql语句的问题 解决方案 去掉mapper.xml中sql的中括号 去掉后成功运行，CCJSqlParserUtil.parse(originalSql)不报错。 ","link":"https://blog.elex.vip/post/sql-server-mybatis-plus-shi-yong-page-shi-bao-cuo/"},{"title":"一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印","content":" 问题由来 解决方案 Lombok主要常用的注解有： 说明 (一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印) 问题由来 最近朋友在群里提了这么一个问题，另外一个朋友回了一句重写toString()? 这确实是一个方法，不过不太方便！ 解决方案 这个问题，记得在一次机缘巧合之下在一篇讲lombok工具包的时候，有提到过。 @ToString(exclude=&quot;column&quot;) 意义：排除column列所对应的元素，即在生成toString方法时不包含column参数； @ToString(exclude={&quot;column1&quot;,&quot;column2&quot;}) 意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数； @ToString(of=&quot;column&quot;) 意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；； @ToString(of={&quot;column1&quot;,&quot;column2&quot;}) 意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数； 下面继续普及下lombok所有注解的说明，顺带巩固下自己的记忆 Lombok主要常用的注解有： @Data,@getter,@setter,@NoArgsConstructor,@AllArgsConstructor,@ToString,@EqualsAndHashCode,@Slf4j,@Log4j。我们一个一个来看： 说明 注解 说明 @Data 在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含getter、setter、NoArgsConstructor、equals、canEqual、hashCode、toString 注解，即当使用当前注解时，会自动生成包含的所有方法； @getter 在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法； @setter 在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法； @NoArgsConstructor 在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法； @AllArgsConstructor 在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法； @ToString 在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法； @EqualsAndHashCode 在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法； @Slf4j 在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可； @Log4j 在需要打印日志的类中使用，当项目中使用了log4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可； ","link":"https://blog.elex.vip/post/yi-ge-dui-xiang-zhong-you-hen-duo-shu-xing-jia-ru-you-ge-shu-xing-bu-xiang-zai-ri-zhi-zhong-da-yin-qi-ta-shu-xing-du-da-yin/"},{"title":"docker 安装Jenkins自动部署SpringBoot项目及所遇到的问题集合","content":"docker安装Jenkins场景： 安装了以下服务 jdk1.8（非docker容器安装） maven3.6.3 （非docker容器安装） docker nginx（docker容器部署） mysql（docker容器部署） redis（docker容器部署） 开始安装Jenkins： 启动docker，通过docker下载Jenkins镜像文件 创建Jenkins挂载目录并授权权限（我们在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。 如果我们不这样做，那么如果需要修改容器配置文件，将会有点麻烦，因为虽然我们可以使用docker exec -it --user root 容器id /bin/bash 命令进入容器目录，但是连简单的 vi命令都不能使用） 创建并启动Jenkins容器 -d 后台运行镜像 -p 8081:8081 将镜像的8081端口映射到服务器的8081端口（后面服务部署用到的端口。docker容器部署，需要把部署项目的端口映射出来） -p 10240:8080 将镜像的8080端口映射到服务器的10240端口 -p 10241:50000 将镜像的50000端口映射到服务器的10241端口 -v /var/jenkins_mount:/var/jenkins_mount /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /var/jenkins_mount目录 -v /etc/localtime:/etc/localtime 让容器使用和服务器同样的时间设置 -v /usr/java/default:/opt/java/openjdk 让容器可以使用服务器的jdk -v /usr/local/apache-maven-3.6.3:/usr/local/maven 让容器可以使用服务器的Maven -v /home/shiyue-ticket/logs/:/home/shiyue-ticket/logs/ 将项目的日志目录挂载道到本地硬盘 -v root 给容器root的权限 --name jenkins 给容器起一个别名 查看jenkins是否启动成功，如下图出现端口号，就为启动成功了 查看docker容器日志 配置镜像加速，进入/var/jenkins_mount/目录 **修改hudson.model.UpdateCenter.xml里的内容 修改前** 将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 修改后 访问Jenkins页面，输入你的ip加上10240 入门 管理员密码获取方法，查看initialAdminPassword文件，把密码输入登录中的密码即可，开始使用。 到此就全部安装完成了 安装Git，GitLab插件： 后期更新 问题： 后期更新 ","link":"https://blog.elex.vip/post/docker-an-zhuang-jenkins-zi-dong-bu-shu-springboot-xiang-mu-ji-suo-yu-dao-de-wen-ti-ji-he/"}]}