{"posts":[{"title":"Docker 常用命令","content":"1. docker 基础命令 1.1. 启动docker命令 1.2. 关闭docker命令 1.3. 重启docker命令 1.4. 查看docker状态命令 1.5. 查看docker版本命令 1.6. 查看docker信息命令 1.7. docker 帮助命令 忘记了某些命令便可使用此进行查看与回顾 比如 咱忘记了 拉取命令 不知道可以带哪些参数 咱可以这样使用 2. docker 镜像命令 2.1. 查看自己服务器中docker 镜像列表 2.2. 搜索镜像 [MirrorName] 镜像名 搜索 STARS &gt;9000的 mysql 镜像 2.3. 拉取镜像 不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本 [MirrorName] 镜像名 [Tag] 版本号 2.4. 运行镜像 [MirrorName] 镜像名 [Tag] 版本号 2.5. 删除镜像 当前镜像没有被任何容器使用才可以删除 [MirrorName] 镜像名 [MirrorID] 镜像ID 2.5.1. 删除一个 2.5.2. 删除多个 其镜像ID或镜像用用空格隔开即可 2.5.3. 删除全部镜像 -a 意思为显示全部, -q 意思为只显示ID 2.6. 强制删除镜像 [MirrorName] 镜像名 [MirrorID] 镜像ID 2.7. 保存镜像 [MirrorName] 镜像名 [MirrorID] 镜像ID exmaple: 2.8. 加载镜像 任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像 [Path] 路径 [FileName] 文件名 3. docker 容器命令 3.1. 查看容器列表 3.1.1. 查看正在运行容器列表 3.1.2. 查看所有容器 包含正在运行 和已停止的 3.2. 构建容器 -it 表示 与容器进行交互式启动 -d 表示可后台运行容器 （守护式运行） --restart=always 容器自动重启 -v 宿主机文件存储位置:容器内文件位置 可同时挂载多个文件，须多个-v [HostFilePath] 宿主机文件存储位置 [ContainerFilePath] 容器内文件位置 --name 给要运行的容器 起的名字 [Alias] 容器别名 -p 宿主机端口:容器端口 [HostPort] 宿主机端口 [ContainerPort] 容器端口 [MirrorName] 镜像名 [MirrorID] 镜像ID /bin/bash 交互路径 3.3. 启动容器 [ContainerName] 容器名称 [ContainerID] 容器ID 3.4. 停止容器 [ContainerName] 容器名称 [ContainerID] 容器ID 3.5. 重启容器 [ContainerName] 容器名称 [ContainerID] 容器ID 3.6. 杀掉容器 [ContainerName] 容器名称 [ContainerID] 容器ID 3.7. 已有容器设置自动重启 [ContainerName] 容器名称 [ContainerID] 容器ID 3.8. 进入容器 [ContainerName] 容器名称 [ContainerID] 容器ID /bin/bash 交互路径 3.9. 容器文件拷贝 无论容器是否开启 都可以进行拷贝 [ContainerName] 容器名称 [ContainerID] 容器ID [ContainerPath] 容器内路径 [HostPath] 宿主机路径 3.9.1. 从容器内拷贝至宿主机 3.9.2. 从宿主机拷贝至容器内 3.10. 查看容器日志 [Line] 行数 要查看末尾多少行 默认all [ContainerName] 容器名称 [ContainerID] 容器ID 3.11. 更换容器名称 [ContainerName] 容器名称 [ContainerID] 容器ID [NewContainerName] 新容器名称 3.12. 查看容器进程 [ContainerName] 容器名称 [ContainerID] 容器ID 3.13. 查看容器信息 [ContainerName] 容器名称 [ContainerID] 容器ID 4. docker 进阶命令 4.1. 提交一个镜像 我们运行的容器可能在镜像的基础上做了一些修改，有时候我们希望保存起来，封装成一个更新的镜像，这时候我们就需要使用 commit 命令来构建一个新的镜像 -m 提交信息 [CommitInfo] 提交信息的内容 -m=&quot;初次提交&quot; -a 作者信息 [Author] 作者信息内容 -a=&quot;Elex&quot; [ContainerName] 容器名称 [ContainerID] 容器ID [MirrorName] 提交的镜像名称 [Tag] 镜像版本号 4.2. 打包一个镜像 -t 镜像名称:镜像版本号 [MirrorName] 打包的镜像名称 [Tag] 镜像版本号 . 当前目录 5. docker 运维命令 5.1. 查看docker工作目录 5.2. 查看docker磁盘占用总体情况 5.3. 查看docker的磁盘使用具体情况 5.4. 删除 无用的容器和 镜像 5.4.1. 删除异常停止的容器 5.4.2. 删除名称或标签为none的镜像 5.5. 清除所有无容器使用的镜像 5.6. 查找大文件 5.7. 查找指定docker使用目录下大于指定大小文件 [Path] 路径 目录 ","link":"https://blog.elex.vip/post/docker-chang-yong-ming-ling/"},{"title":"SpringBoot集成Quartz自定义表管理定时器","content":"前言 本文章中出现的第三方框架方法：MySQL-Plus，Hutools，Quartz。 1. 建表 2. 导包 3. 添加配置文件 在resources下添加quartz.properties配置文件 4. 添加定时器工厂类 5. 添加定时器配置 6. 定时任务操作类 7. 定时任务实体 7.1. 任务操作类型枚举 7.1.1. 任务状态枚举 7.1.2. 任务状态枚举 7.1.3. 任务类型枚举 8. 定时任务操作接口 8.1. 定时任务操作接口类 8.2. 定时任务操作接口实现类 9. 启动初始化加载任务 ","link":"https://blog.elex.vip/post/springboot-ji-cheng-quartz-zi-ding-yi-biao-guan-li-ding-shi-qi/"},{"title":"java面试题之HashMap常见面试题总结","content":"“你用过HashMap吗？” “什么是HashMap？你为什么用到它？” 几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。 “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。 “如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？” 除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。如果你能够回答这道问题，下面的问题来了： “你了解重新调整HashMap大小存在什么问题吗？” 你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：） “为什么String, Interger这样的wrapper类适合作为键？” String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 “我们可以使用自定义的对象作为键吗？ ”这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 “我们可以使用CocurrentHashMap来代替Hashtable吗？” 这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。 这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结 HashMap的工作原理HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。因为HashMap的好处非常多，在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章: ","link":"https://blog.elex.vip/post/java-mian-shi-ti-zhi-hashmap-chang-jian-mian-shi-ti-zong-jie/"},{"title":"BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）","content":" 前后端交互BigDecimal类型字段丢失精度 例如 解决方案 注解解释 (BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）) 前后端交互BigDecimal类型字段丢失精度 例如 postman 的返回： 例如 前端接收 的返回： 实体类里的字段类型： 例如 该字段的值为 “ 12345671234567.12345”，到前端就变成了 “12345671234567.123”，前端要求保留所有小数。 解决方案 在需要转化的字段上添加 @JsonFormat(shape = JsonFormat.Shape.STRING) 注解 注解解释 @JsonFormat 用来表示json序列化的一种格式或者类型，shap表示序列化后的一种类型 ","link":"https://blog.elex.vip/post/bigdecimal-postman-fan-hui-zheng-chang-jing-du-qian-duan-jie-shou-bu-zheng-chang-qian-hou-duan-jiao-hu-diu-shi-jing-du/"},{"title":"Java-Poi 指定列单元格式","content":" POI导出设置某列值为文本格式 HSSFWorkbook方式 XSSFWorkbook方式 ( Java-Poi 指定列单元格式) POI导出设置某列值为文本格式 HSSFWorkbook方式 XSSFWorkbook方式 poi的jar包版本：3.10 ","link":"https://blog.elex.vip/post/java-poi-zhi-ding-lie-dan-yuan-ge-shi/"},{"title":"Sql Server + Mybatis-plus使用Page时报错","content":" “OFFSET”附近有语法错误 代码实现 错误信息 解决过程 定位问题 解决方案 (Sql Server + Mybatis-plus使用Page时报错：) “OFFSET”附近有语法错误 最近开发遇到的问题，SqlServer+Mybatis-Plus Page插件进行分页时的报错 代码实现 Maven依赖 Mapper.xml 错误信息 解决过程 定位问题 找到报错的sql 控制显示的一句异常信息 进入com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor.java,在concatOrderBy打上断点 在执行该句代码时异常： 在控制台debug监视CCJSqlParserUtil.parse(originalSql)，直接抛出异常，是sql语句的问题 解决方案 去掉mapper.xml中sql的中括号 去掉后成功运行，CCJSqlParserUtil.parse(originalSql)不报错。 ","link":"https://blog.elex.vip/post/sql-server-mybatis-plus-shi-yong-page-shi-bao-cuo/"},{"title":"一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印","content":" 问题由来 解决方案 Lombok主要常用的注解有： 说明 (一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印) 问题由来 最近朋友在群里提了这么一个问题，另外一个朋友回了一句重写toString()? 这确实是一个方法，不过不太方便！ 解决方案 这个问题，记得在一次机缘巧合之下在一篇讲lombok工具包的时候，有提到过。 @ToString(exclude=&quot;column&quot;) 意义：排除column列所对应的元素，即在生成toString方法时不包含column参数； @ToString(exclude={&quot;column1&quot;,&quot;column2&quot;}) 意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数； @ToString(of=&quot;column&quot;) 意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；； @ToString(of={&quot;column1&quot;,&quot;column2&quot;}) 意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数； 下面继续普及下lombok所有注解的说明，顺带巩固下自己的记忆 Lombok主要常用的注解有： @Data,@getter,@setter,@NoArgsConstructor,@AllArgsConstructor,@ToString,@EqualsAndHashCode,@Slf4j,@Log4j。我们一个一个来看： 说明 注解 说明 @Data 在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含getter、setter、NoArgsConstructor、equals、canEqual、hashCode、toString 注解，即当使用当前注解时，会自动生成包含的所有方法； @getter 在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法； @setter 在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法； @NoArgsConstructor 在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法； @AllArgsConstructor 在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法； @ToString 在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法； @EqualsAndHashCode 在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法； @Slf4j 在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可； @Log4j 在需要打印日志的类中使用，当项目中使用了log4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可； ","link":"https://blog.elex.vip/post/yi-ge-dui-xiang-zhong-you-hen-duo-shu-xing-jia-ru-you-ge-shu-xing-bu-xiang-zai-ri-zhi-zhong-da-yin-qi-ta-shu-xing-du-da-yin/"},{"title":"docker 安装Jenkins自动部署SpringBoot项目及所遇到的问题集合","content":"docker安装Jenkins场景： 安装了以下服务 jdk1.8（非docker容器安装） maven3.6.3 （非docker容器安装） docker nginx（docker容器部署） mysql（docker容器部署） redis（docker容器部署） 开始安装Jenkins： 启动docker，通过docker下载Jenkins镜像文件 创建Jenkins挂载目录并授权权限（我们在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。 如果我们不这样做，那么如果需要修改容器配置文件，将会有点麻烦，因为虽然我们可以使用docker exec -it --user root 容器id /bin/bash 命令进入容器目录，但是连简单的 vi命令都不能使用） 创建并启动Jenkins容器 -d 后台运行镜像 -p 8081:8081 将镜像的8081端口映射到服务器的8081端口（后面服务部署用到的端口。docker容器部署，需要把部署项目的端口映射出来） -p 10240:8080 将镜像的8080端口映射到服务器的10240端口 -p 10241:50000 将镜像的50000端口映射到服务器的10241端口 -v /var/jenkins_mount:/var/jenkins_mount /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /var/jenkins_mount目录 -v /etc/localtime:/etc/localtime 让容器使用和服务器同样的时间设置 -v /usr/java/default:/opt/java/openjdk 让容器可以使用服务器的jdk -v /usr/local/apache-maven-3.6.3:/usr/local/maven 让容器可以使用服务器的Maven -v /home/shiyue-ticket/logs/:/home/shiyue-ticket/logs/ 将项目的日志目录挂载道到本地硬盘 -v root 给容器root的权限 --name jenkins 给容器起一个别名 查看jenkins是否启动成功，如下图出现端口号，就为启动成功了 查看docker容器日志 配置镜像加速，进入/var/jenkins_mount/目录 **修改hudson.model.UpdateCenter.xml里的内容 修改前** 将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 修改后 访问Jenkins页面，输入你的ip加上10240 入门 管理员密码获取方法，查看initialAdminPassword文件，把密码输入登录中的密码即可，开始使用。 到此就全部安装完成了 安装Git，GitLab插件： 后期更新 问题： 后期更新 ","link":"https://blog.elex.vip/post/docker-an-zhuang-jenkins-zi-dong-bu-shu-springboot-xiang-mu-ji-suo-yu-dao-de-wen-ti-ji-he/"}]}