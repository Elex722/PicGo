<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.elex.vip</id>
    <title>Elex&apos;Blog</title>
    <updated>2022-03-23T09:35:34.953Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.elex.vip"/>
    <link rel="self" href="https://blog.elex.vip/atom.xml"/>
    <subtitle>To be or not to be, that&amp;acute;s a question.</subtitle>
    <logo>https://blog.elex.vip/images/avatar.png</logo>
    <icon>https://blog.elex.vip/favicon.ico</icon>
    <rights>All rights reserved 2022, Elex&apos;Blog</rights>
    <entry>
        <title type="html"><![CDATA[java面试题之HashMap常见面试题总结]]></title>
        <id>https://blog.elex.vip/post/java-mian-shi-ti-zhi-hashmap-chang-jian-mian-shi-ti-zong-jie/</id>
        <link href="https://blog.elex.vip/post/java-mian-shi-ti-zhi-hashmap-chang-jian-mian-shi-ti-zong-jie/">
        </link>
        <updated>2022-03-23T05:32:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="你用过hashmap吗-什么是hashmap你为什么用到它">“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</h2>
<p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p>
<h2 id="你知道hashmap的工作原理吗-你知道hashmap的get方法的工作原理吗">“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</h2>
<p>HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。</p>
<h2 id="当两个对象的hashcode相同会发生什么">“当两个对象的hashcode相同会发生什么？”</h2>
<p>从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p>
<h2 id="如果两个键的hashcode相同你如何获取值对象">“如果两个键的hashcode相同，你如何获取值对象？”</h2>
<p>面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。</p>
<h2 id="如果hashmap的大小超过了负载因子load-factor定义的容量怎么办">“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”</h2>
<p>除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。如果你能够回答这道问题，下面的问题来了：</p>
<h2 id="你了解重新调整hashmap大小存在什么问题吗">“你了解重新调整HashMap大小存在什么问题吗？”</h2>
<p>你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p>
<h2 id="为什么string-interger这样的wrapper类适合作为键">“为什么String, Interger这样的wrapper类适合作为键？”</h2>
<p>String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 “我们可以使用自定义的对象作为键吗？ ”这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</p>
<h2 id="我们可以使用cocurrenthashmap来代替hashtable吗">“我们可以使用CocurrentHashMap来代替Hashtable吗？”</h2>
<p>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。</p>
<p>这些问题设计哪些知识点：</p>
<p>hashing的概念<br>
HashMap中解决碰撞的方法<br>
equals()和hashCode()的应用，以及它们在HashMap中的重要性<br>
不可变对象的好处<br>
HashMap多线程的条件竞争<br>
重新调整HashMap的大小</p>
<p><strong>总结</strong><br>
HashMap的工作原理HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。因为HashMap的好处非常多，在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章:</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）]]></title>
        <id>https://blog.elex.vip/post/bigdecimal-postman-fan-hui-zheng-chang-jing-du-qian-duan-jie-shou-bu-zheng-chang-qian-hou-duan-jiao-hu-diu-shi-jing-du/</id>
        <link href="https://blog.elex.vip/post/bigdecimal-postman-fan-hui-zheng-chang-jing-du-qian-duan-jie-shou-bu-zheng-chang-qian-hou-duan-jiao-hu-diu-shi-jing-du/">
        </link>
        <updated>2022-03-23T05:27:23.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92bigdecimal%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6">前后端交互BigDecimal类型字段丢失精度</a>
<ul>
<li><a href="#%E4%BE%8B%E5%A6%82">例如</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
<li><a href="#%E6%B3%A8%E8%A7%A3%E8%A7%A3%E9%87%8A">注解解释</a></li>
</ul>
</li>
</ul>
(BigDecimal Postman 返回正常精度前端接收不正常（前后端交互丢失精度）)</p>
<h1 id="前后端交互bigdecimal类型字段丢失精度">前后端交互BigDecimal类型字段丢失精度</h1>
<p>例如 postman 的返回：<br>
<img src="https://img-blog.csdnimg.cn/20210330110546552.png" alt="在这里插入图片描述" loading="lazy"><br>
例如 前端接收 的返回：<br>
<img src="https://img-blog.csdnimg.cn/20210330111222296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzIyMDY1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
实体类里的字段类型：<br>
<img src="https://img-blog.csdnimg.cn/20210330111249305.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="例如">例如</h2>
<p>该字段的值为  “ 12345671234567.12345”，到前端就变成了 “12345671234567.123”，前端要求保留所有小数。</p>
<h2 id="解决方案">解决方案</h2>
<p>在需要转化的字段上添加   <code>@JsonFormat(shape = JsonFormat.Shape.STRING)</code> 注解<br>
<img src="https://img-blog.csdnimg.cn/20210330112137151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzIyMDY1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="注解解释">注解解释</h2>
<p><code>@JsonFormat</code> 用来表示json序列化的一种格式或者类型，shap表示序列化后的一种类型</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java-Poi 指定列单元格式]]></title>
        <id>https://blog.elex.vip/post/java-poi-zhi-ding-lie-dan-yuan-ge-shi/</id>
        <link href="https://blog.elex.vip/post/java-poi-zhi-ding-lie-dan-yuan-ge-shi/">
        </link>
        <updated>2022-03-23T05:17:40.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#poi%E5%AF%BC%E5%87%BA%E8%AE%BE%E7%BD%AE%E6%9F%90%E5%88%97%E5%80%BC%E4%B8%BA%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F">POI导出设置某列值为文本格式</a>
<ul>
<li><a href="#hssfworkbook%E6%96%B9%E5%BC%8F">HSSFWorkbook方式</a></li>
<li><a href="#xssfworkbook%E6%96%B9%E5%BC%8F">XSSFWorkbook方式</a></li>
</ul>
</li>
</ul>
( Java-Poi 指定列单元格式)</p>
<h1 id="poi导出设置某列值为文本格式">POI导出设置某列值为文本格式</h1>
<h2 id="hssfworkbook方式">HSSFWorkbook方式</h2>
<pre><code class="language-java">// 设置单元格格式为文本格式
HSSFCellStyle textStyle = workBook.createCellStyle();
HSSFDataFormat format = workBook.createDataFormat();
//设置单元格格式为&quot;文本&quot;
textStyle.setDataFormat(format.getFormat(&quot;@&quot;));
sheet.setDefaultColumnStyle(6, textStyle);
</code></pre>
<h2 id="xssfworkbook方式">XSSFWorkbook方式</h2>
<pre><code class="language-java">// 设置单元格格式为文本格式
XSSFCellStyle css = (XSSFCellStyle) workbook.createCellStyle();
XSSFDataFormat format = (XSSFDataFormat) workbook.createDataFormat();
//设置单元格格式为&quot;文本&quot;
css.setDataFormat(format.getFormat(&quot;@&quot;));
sheet.setDefaultColumnStyle(6, css);
</code></pre>
<p>poi的jar包版本：3.10</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sql Server + Mybatis-plus使用Page时报错]]></title>
        <id>https://blog.elex.vip/post/sql-server-mybatis-plus-shi-yong-page-shi-bao-cuo/</id>
        <link href="https://blog.elex.vip/post/sql-server-mybatis-plus-shi-yong-page-shi-bao-cuo/">
        </link>
        <updated>2022-03-23T05:10:05.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#offset%E9%99%84%E8%BF%91%E6%9C%89%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF">“OFFSET”附近有语法错误</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
<li><a href="#%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF">错误信息</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B">解决过程</a>
<ul>
<li><a href="#%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">定位问题</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
</ul>
</li>
</ul>
(Sql Server + Mybatis-plus使用Page时报错：)</p>
<h1 id="offset附近有语法错误">“OFFSET”附近有语法错误</h1>
<p>最近开发遇到的问题，SqlServer+Mybatis-Plus Page插件进行分页时的报错<br>
<img src="https://img-blog.csdnimg.cn/20210520163738338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzIyMDY1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="代码实现">代码实现</h2>
<p>Maven依赖</p>
<pre><code class="language-java">&lt;!-- mybatis-plus --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.baomidou&lt;/groupId&gt;
	&lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
	&lt;version&gt;${mybatis-plus.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Mapper.xml</p>
<pre><code class="language-java">SELECT 
	zp1.[DESCRIPTION] AS [STATUS_NAME],
    ds.[STATUS_DATE],
    cu.[USER_NAME],
    ds.[REMARK]
FROM [DEPOSIT_STATUS] AS ds
    LEFT JOIN [ZA_P_1] AS zp1 ON zp1.[CODE]= ds.[STATUS_CODE]
    LEFT JOIN [CLIENT_USER] AS cu ON cu.[USER_ID]= ds.[CREATE_USERID]
WHERE
    ds.[DELETE_DATE] IS NULL
    AND ds.[DEPOSIT_ID] = #{vo.depositId,jdbcType=INTEGER}
ORDER BY ds.[LAST_COMMIT_DATE]
</code></pre>
<h2 id="错误信息">错误信息</h2>
<pre><code class="language-java">Error querying database.  Cause: com.microsoft.sqlserver.jdbc.SQLServerException: 除非另外还指定了 TOP、OFFSET 或 FOR XML，否则，ORDER BY 子句在视图、内联函数、派生表、子查询和公用表表达式中无效。
</code></pre>
<h2 id="解决过程">解决过程</h2>
<h3 id="定位问题">定位问题</h3>
<p>找到报错的sql</p>
<pre><code class="language-java">SELECT 
	zp1.[DESCRIPTION] AS [STATUS_NAME],
    ds.[STATUS_DATE],
    cu.[USER_NAME],
    ds.[REMARK]
FROM [DEPOSIT_STATUS] AS ds
    LEFT JOIN [ZA_P_1] AS zp1 ON zp1.[CODE]= ds.[STATUS_CODE]
    LEFT JOIN [CLIENT_USER] AS cu ON cu.[USER_ID]= ds.[CREATE_USERID]
WHERE
    ds.[DELETE_DATE] IS NULL
    AND ds.[DEPOSIT_ID] = #{vo.depositId,jdbcType=INTEGER}
ORDER BY ds.[LAST_COMMIT_DATE]
</code></pre>
<p>控制显示的一句异常信息</p>
<pre><code class="language-java">WARN    at com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor.concatOrderBy(PaginationInterceptor.java:142)- failed to concat orderBy from IPage, exception=null
</code></pre>
<p>进入com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor.java,在concatOrderBy打上断点<br>
在执行该句代码时异常：</p>
<pre><code class="language-java">Select selectStatement = (Select)CCJSqlParserUtil.parse(originalSql);
</code></pre>
<p>在控制台debug监视CCJSqlParserUtil.parse(originalSql)，直接抛出异常，是sql语句的问题</p>
<h3 id="解决方案">解决方案</h3>
<p>去掉mapper.xml中sql的中括号</p>
<pre><code class="language-java">SELECT zp1.DESCRIPTION AS STATUS_NAME,
       ds.STATUS_DATE,
       cu.USER_NAME,
       ds.REMARK
FROM DEPOSIT_STATUS AS ds
         LEFT JOIN ZA_P_1 AS zp1 ON zp1.CODE= ds.STATUS_CODE
    AND TYPE= 11
         LEFT JOIN CLIENT_USER AS cu ON cu.USER_ID= ds.CREATE_USERID
WHERE
    ds.DELETE_DATE IS NULL
  AND ds.DEPOSIT_ID = #{vo.depositId,jdbcType=INTEGER}
  AND ds.CLIENT_ID = #{vo.clientId,jdbcType=INTEGER}
ORDER BY ds.LAST_COMMIT_DATE
</code></pre>
<p>去掉后成功运行，CCJSqlParserUtil.parse(originalSql)不报错。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印]]></title>
        <id>https://blog.elex.vip/post/yi-ge-dui-xiang-zhong-you-hen-duo-shu-xing-jia-ru-you-ge-shu-xing-bu-xiang-zai-ri-zhi-zhong-da-yin-qi-ta-shu-xing-du-da-yin/</id>
        <link href="https://blog.elex.vip/post/yi-ge-dui-xiang-zhong-you-hen-duo-shu-xing-jia-ru-you-ge-shu-xing-bu-xiang-zai-ri-zhi-zhong-da-yin-qi-ta-shu-xing-du-da-yin/">
        </link>
        <updated>2022-03-23T03:27:02.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%97%AE%E9%A2%98%E7%94%B1%E6%9D%A5">问题由来</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a>
<ul>
<li><a href="#lombok%E4%B8%BB%E8%A6%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89">Lombok主要常用的注解有：</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
</ul>
</li>
</ul>
(一个对象中有很多属性，假如有个属性不想在日志中打印，其他属性都打印)</p>
<h1 id="问题由来">问题由来</h1>
<p>最近朋友在群里提了这么一个问题，另外一个朋友回了一句重写toString()?<br>
这确实是一个方法，不过不太方便！<br>
<img src="https://img-blog.csdnimg.cn/20210521174213174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzIyMDY1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="解决方案">解决方案</h1>
<p>这个问题，记得在一次机缘巧合之下在一篇讲lombok工具包的时候，有提到过。</p>
<p><mark>@ToString(exclude=&quot;column&quot;)</mark></p>
<p>意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；</p>
<p><mark>@ToString(exclude={&quot;column1&quot;,&quot;column2&quot;})</mark></p>
<p>意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；</p>
<p><mark>@ToString(of=&quot;column&quot;)</mark></p>
<p>意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；</p>
<p><mark>@ToString(of={&quot;column1&quot;,&quot;column2&quot;})</mark></p>
<p>意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；</p>
<p>下面继续普及下lombok所有注解的说明，顺带巩固下自己的记忆</p>
<h2 id="lombok主要常用的注解有">Lombok主要常用的注解有：</h2>
<p>@Data,@getter,@setter,@NoArgsConstructor,@AllArgsConstructor,@ToString,@EqualsAndHashCode,@Slf4j,@Log4j。我们一个一个来看：</p>
<h2 id="说明">说明</h2>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Data</td>
<td>在JavaBean或类JavaBean中使用，这个注解包含范围最广，它包含getter、setter、NoArgsConstructor、equals、canEqual、hashCode、toString 注解，即当使用当前注解时，会自动生成包含的所有方法；</td>
</tr>
<tr>
<td>@getter</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会生成对应的getter方法；</td>
</tr>
<tr>
<td>@setter</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会生成对应的setter方法；</td>
</tr>
<tr>
<td>@NoArgsConstructor</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会生成对应的无参构造方法；</td>
</tr>
<tr>
<td>@AllArgsConstructor</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会生成对应的有参构造方法；</td>
</tr>
<tr>
<td>@ToString</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法；</td>
</tr>
<tr>
<td>@EqualsAndHashCode</td>
<td>在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的equals方法和hashCode方法；</td>
</tr>
<tr>
<td>@Slf4j</td>
<td>在需要打印日志的类中使用，当项目中使用了slf4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；</td>
</tr>
<tr>
<td>@Log4j</td>
<td>在需要打印日志的类中使用，当项目中使用了log4j打印日志框架时使用该注解，会简化日志的打印流程，只需调用info方法即可；</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker 安装Jenkins自动部署SpringBoot项目及所遇到的问题集合]]></title>
        <id>https://blog.elex.vip/post/docker-an-zhuang-jenkins-zi-dong-bu-shu-springboot-xiang-mu-ji-suo-yu-dao-de-wen-ti-ji-he/</id>
        <link href="https://blog.elex.vip/post/docker-an-zhuang-jenkins-zi-dong-bu-shu-springboot-xiang-mu-ji-suo-yu-dao-de-wen-ti-ji-he/">
        </link>
        <updated>2022-03-22T07:50:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="docker安装jenkins场景">docker安装Jenkins场景：</h1>
<font color=#999AAA >
安装了以下服务
<ul>
<li>jdk1.8（非docker容器安装）</li>
<li>maven3.6.3 （非docker容器安装）</li>
<li>docker</li>
<li>nginx（docker容器部署）</li>
<li>mysql（docker容器部署）</li>
<li>redis（docker容器部署）<br>
</font></li>
</ul>
<h1 id="开始安装jenkins">开始安装Jenkins：</h1>
<ol>
<li>启动docker，通过docker下载Jenkins镜像文件</li>
</ol>
<pre><code class="language-bash">docker pull jenkins/jenkins:latest
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/img_convert/eb72e0c4b28ac6f1daff510d61234e8a.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol start="2">
<li>创建Jenkins挂载目录并授权权限（我们在服务器上先创建一个jenkins工作目录 /var/jenkins_mount，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。 如果我们不这样做，那么如果需要修改容器配置文件，将会有点麻烦，因为虽然我们可以使用docker exec -it --user root 容器id /bin/bash 命令进入容器目录，但是连简单的 vi命令都不能使用）</li>
</ol>
<pre><code class="language-bash">mkdir -p /var/jenkins_mount
</code></pre>
<pre><code class="language-bash">chmod 777 /var/jenkins_mount
</code></pre>
<ol start="3">
<li>创建并启动Jenkins容器<br>
-d   后台运行镜像<br>
-p   8081:8081  将镜像的8081端口映射到服务器的8081端口（后面服务部署用到的端口。docker容器部署，需要把部署项目的端口映射出来）<br>
-p   10240:8080  将镜像的8080端口映射到服务器的10240端口<br>
-p   10241:50000  将镜像的50000端口映射到服务器的10241端口<br>
-v   /var/jenkins_mount:/var/jenkins_mount  /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /var/jenkins_mount目录<br>
-v   /etc/localtime:/etc/localtime 让容器使用和服务器同样的时间设置<br>
-v   /usr/java/default:/opt/java/openjdk  让容器可以使用服务器的jdk<br>
-v   /usr/local/apache-maven-3.6.3:/usr/local/maven   让容器可以使用服务器的Maven<br>
-v   /home/shiyue-ticket/logs/:/home/shiyue-ticket/logs/   将项目的日志目录挂载道到本地硬盘<br>
-v   root   给容器root的权限<br>
--name   jenkins   给容器起一个别名</li>
</ol>
<pre><code class="language-bash">docker run -d -p 8081:8081 -p 10240:8080 -p 10241:50000 -v /var/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime -v /usr/java/default:/opt/java/openjdk -v /usr/local/apache-maven-3.6.3:/usr/local/maven -v /home/shiyue-ticket/logs/:/home/shiyue-ticket/logs/  --name jenkins -u root jenkins/jenkins
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/be99f1939edc478c8b4e114560dfec1e.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol start="4">
<li>查看jenkins是否启动成功，如下图出现端口号，就为启动成功了</li>
</ol>
<pre><code class="language-bash">docker ps -l
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/1ffa6654ee3d4718b32fcba4ee77a4b7.png#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol start="5">
<li>查看docker容器日志</li>
</ol>
<pre><code class="language-bash">docker logs jenkins
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/cfa88a461d0c4b748162226595efe038.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUG9vciBXcmV0Y2jCsA==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" loading="lazy"></figure>
<ol start="6">
<li>配置镜像加速，进入<code>/var/jenkins_mount/</code>目录</li>
</ol>
<pre><code class="language-bash">cd /var/jenkins_mount/
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/b910aa7ec31e43dbb572eea540b7307d.png#pic_center" alt="在这里插入图片描述" loading="lazy"><br>
**修改<code>hudson.model.UpdateCenter.xml</code>里的内容</p>
<p>修改前**<br>
<img src="https://img-blog.csdnimg.cn/31d250a7af9f4b22bf7809510fe7cd27.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>将 url 修改为 清华大学官方镜像：https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</p>
<p><strong>修改后</strong><br>
<img src="https://img-blog.csdnimg.cn/9615a28a5a964fa8a5f80473dea1cce0.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<ol start="7">
<li>
<p>访问Jenkins页面，输入你的ip加上10240<br>
入门<br>
<img src="https://img-blog.csdnimg.cn/img_convert/b85730023a205562da6f17c70a4a5a06.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
</li>
<li>
<p>管理员密码获取方法，查看<code>initialAdminPassword</code>文件，把密码输入登录中的密码即可，开始使用。</p>
</li>
</ol>
<pre><code class="language-bash">cat /var/jenkins_mount/secrets/initialAdminPassword
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/5adfc6c811164fc6987c8656838b0f8b.png" alt="在这里插入图片描述" loading="lazy"></figure>
<ol start="9">
<li>到此就全部安装完成了</li>
</ol>
<h1 id="安装gitgitlab插件">安装Git，GitLab插件：</h1>
<p>后期更新</p>
<h1 id="问题">问题：</h1>
<p>后期更新</p>
]]></content>
    </entry>
</feed>